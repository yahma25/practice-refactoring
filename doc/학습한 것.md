# 학습한 것

<br>

## 리팩터링

<br>

### 주요 단계

* **반복문 쪼개기:** 변수 값을 누적시키는 부분을 분리한다.
* **문장 슬라이드하기:** 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
* **함수 추출하기:** 계산 부분을 별도 함수로 추출한다.
* **변수 인라인하기:** 임시 변수를 제거하고 함수로 대체한다.
* **조건부 로직을 다형성으로 바꾸기:** 클래스 상속을 이용하여 조건부 대체(팩토리 패턴으로 객체 생성)
* **단계 쪼개기:** 계산, 출력 등의 코드 분리

<br>

### 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다

> 실무에서 리팩터링 전담 팀/팀원이 있었는데 테스트 코드가 없던 레거시 코드가 대부분이어서 배포 때마다 높은 확률로 에러가 발생했었다.

<br>

### 함수 추출하기 = 긴 함수를 리팩터링할 때는 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다

<br>

### 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다

<br>

### 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다

> 리팩터링이 아니어도 코드를 수정하고 나면 짧은 주기로 결과를 확인하면서 진행해야 실수했을 때 원인을 보다 쉽게 찾을 수 있었다.

<br>

### 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다 by 켄트 벡

> 큽... 켄트 벡님!

<br>

### 간결함이 지혜의 정수일지 몰라도, 프로그래밍에서만큼은 명료함이 진화할 수 있는 소프트웨어의 정수다

<br>

## 이 외

<br>

### 임시 변수는 가능한 줄이자

> 평소에 let 보단 const를 사용하는 것만 생각해봤지, 임시 변수는 생각해본 적이 없었던 것 같다. 그렇다고 최소 단위 함수를 만들어서 사용한 것이 아니었으니 앞으로는 인지할 필요가 있다.

<br>

### 반복문 중복을 꺼려하지 말자. 특별한 경우가 아니라면 성능에 큰 영향을 주지 않으니 무시한다. 성능이 떨어진다면, 리팩터링을 마무리하고 나서 성능을 개선하자

> 코드를 수정하면서 바로 떠올렸던 부분이다. 반복 횟수가 몇 개가 될지 모르는데 굳이 또 반복 하다니... 하지만, 최적화를 위해 한 루프에 몰아 넣는 것보단 가독성과 수정이 용이하게 분리하는 것이 더 낫다고 생각한다.

<br>

### 조건부 로직을 다형성으로 바꾸기

> 언제부턴가 코드의 양이 적다고(1~2줄) 생각하여, 클래스를 늘리는 것보단 switch/if로 다 해결해버리고 있는 것 같다.

<br>

### 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다

> 100% 동의. 라이브 서비스 코드는 계속해서 진화하기 때문에 대부분의 시간을 유지보수로 보낸다. 그러므로, 멋진 아키텍쳐 구조보다는 조금 부실해도 쉽게 변경할 수 있는 코드를 작성할 수 있어야 한다.

<br>

## 테스트 코드 (Jest)

<br>

### 비교

문자열을 비교할 때는 `toMatch`를 사용해야 한다.
`toBe` or `toEqual`은 객체 비교에 적합하다.

<br>

### 완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다

> 알고 있었으면서도, 바쁠때면 다시 잊게된다...

<br>

### 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자

> 의도한대로 결과가 나왔는데 음수 값, 공백 등이 될 때 이런 경우도 고객에게 의미있는 값인지 확인 필요

<br>

## ECMAScript

<br>

### ES5

getter/setter 지원

### ES6

super.getter/setter 지원
